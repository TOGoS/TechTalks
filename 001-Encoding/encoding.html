<html>
<head>
<title>This is not a character: The treachery of byte sequences</title>
<link rel="stylesheet" type="text/css" href="../style/article.css"/>
</head>
<body>

<p>Welcome to my tech talk.  I actually plan for this to be the first in a series.  The series is called:</p>

<hr />

<h1>Be Explicit</h1>

<p>And has the subtitle:</p>

<hr />

<h3>English is full of ambiguities.  Your programs should not be.</h3>

<p>To get started, I will use an example:</p>

<hr />

<blockquote class="signquot">
<img src="../images/MagrittePipe.jpg" style="width:90%" alt="This is not a pipe"/>
</blockquote>

<p>Actually that text isn't English; it's French.  It says "This is not a pipe".</p>

<p>(Question to audience) Who knows why this is paradoxical?</p>

<p>(Question to audience) Who knows why it's <em>not</em> paradoxical?</p>

<p>If you take 'this' to mean the object depicted in the picture, then the text would be wrong, since that thing obviously <em>is</em> a pipe.  So either the artist is lying, or was using 'this' to refer to something else.  I think what he meant is that the picture <em>itself</em> is not a pipe.  To clarify things, he could have written something like:</p>

<hr />

<blockquote class="signquot">
<img src="../images/MagrittePipeClarified.jpg" style="width:90%" alt="The object depicted in this picture is a pipe.  The picture itself is <em>not</em> a pipe."/>
</blockquote>

<p>But art works are more fun when they're full of ambiguities.  Ambiguities also form the foundation of many intro to philosophy courses.  But they're not usually useful when you're making engineering decisions.  So, given that, I'm going to spend this talk prattling on about  how the world will make more sense and your programs will be more 'robust' if you make sure to define what exactly it is you're talking about.</p>

<!--
<p>Assuming I actually do get around to doing more of these, it's going to be kind of like the ISP class they had me take in high school.  That class was about a lot of different things but it all tied back into the idea that energy is always conserved, and that you could use that fact to help solve lots of different equations.  Similarly, I hope to touch on several topics that I think are interesting and/or useful, but always emphasizing that main idea.</p>

<p>TODO: Cut this down by 2/3rds so people don't fall asleep and/or leave.</p>
-->

<p>Now on to today's sub-topic.</p>

<hr />

<h2>This is not a character</h2>

<!--
<p>Even the sub-topic has a subtitle:</p>
-->

<hr />

<h3>The treachery of byte sequences</h3>

<!--
<p>This is going to be about character encoding.</p>
-->

<p>Regarding paying proper attention to character encodings, a wise man once said</p>

<hr />

<blockquote class="signquot">IT'S NOT THAT HARD</blockquote>

<p>Joel has a really <a href="http://www.joelonsoftware.com/articles/Unicode.html">nice article</a> about things like ASCII, Unicode, and UTF-8, but I'm going to go at this from more of a '<i>just be sure to keep track of how your strings are encoded and everything will work out fine</i>' perspective, skipping over specific encoding details.</p>

<hr />

<p>(Question to audience) What's this?</p>

<p class="signquot">&#35987;</p>

<p>Actually, I need to clarify what I mean by 'this'.  I don't mean the pixels on the screen, I don't mean the wall.  What I mean is: what do these lines and squiggles represent?</p>

<p>The short answer is that it's the traditional chinese character for 'cat'.  It's not a number, it's not a specific picture (since you could draw it many different ways and people would still recognise it as the same character), and it's certainly not an actual cat.  Like the letter 'A', it's an abstract object that happens to have a commonly recognised representation and a commonly understood meaning.  That bunch of lines projected on the wall is just a way of communicating it to you.</p>

<p>(Question to audience) So how does a computer represent such a thing?</p>

<p>That's kind of a trick question.  A computer could represent it lots of ways.  It could store a that bunch of lines as a bitmap, or it could store a recording of someone saying the word.  But to make things easy, computers usually represent these things as numbers.  At least until it's time to show them to a human.  Then they turn them into bitmaps and send them to a display device or something.  But right now I want to talk about numbers.</p>

<p>The next point being: what's the number for &#35987;?</p>

<p><em>If</em> things were all screwed up, everyone and their brother
would come up with their own number for each character, and nobody would be
able to talk to anyone else.  Fortunately for us programmers there's this thing
called</p>

<hr />

<p class="signquot">Unicode</p>

<p>Unicode makes deciding what number to use for any given character easy, because it explicitly defines which number goes with each character.  That's all Unicode is.  A standard, widely-used, character number map.  In character set terminology, each of these numbers is called "a code point", by the way.</p>

<hr />

<p>Here're a few Uni-code points:</p>

<center><table class="signquot">
<tr><th>Character</th><th>Number</th></tr>
<tr><td>A</td><td>65</td>
<tr><td>a</td><td>97</td>
<tr><td>&lt;</td><td>60</td>
<tr><td>&#35987;</td><td>35987</td>
</table></center>

<!--
<p>I can say "character" here instead of "pictoral representation of character", because if you consider this entire document to be made up of characters, along with some formatting information.  What you're seeing on the wall here is not the document itself, but a picture of a section of the document (or a section of a picture of it).  But I'll talk more about that distinction another time.</p>
-->

<p>(Question to audience) Any questions so far?</p>

<p>The next question we need to ask ourselves is: how does the computer represent those numbers?  Keep in mind that the numbers for most characters won't fit in 8 bits, and that sometimes you need certain characters to mean special things, like angle brackets in HTML.  So this problem is a tad more complicated.</p>

<p>Fortunately, you can still keep things easy simply by being aware of how
the characters you are working with are encoded, and what format the program you
are sending them to is expecting.  If they do not match, then you convert.</p>

<p>So let's start with the simplest case.</p>

<hr />

<p class="signquot">text/plain
<br />a.k.a. Plain Text</p>

<p>In a 'plain text' string, every character means itself.  This can be contrasted with things like HTML, where ampersands, angle brackets, and sometimes quotes don't represent actually represent themselves in the document because they are used for metadata and escape sequences.  It is also different from literal string syntax in many programming languages where backslashes have a special meaning, and don't actually mean backslash unless you put two of them together, in which case they mean one backslash.</p>

<p>So in that regard, plain text is pretty simple.  What makes it tricky is that strings in computers are not usually stored as character sequences, but rather as byte sequences, and therefore...</p>

<hr />

<p class="signquot">...we must specify how to interpret bytes as characters, and how to store characters as bytes.</p>

<p>This pair of conversion functions is called a "character encoding".  There are many encodings to choose from.  A lot of problems are caused by people not paying attention to which ones they are using.</p>

<hr />

<p>Here is a list of some common encodings:</p>

<ul class="signquot" style="text-align:left; margin-left:auto; margin-right:auto">
<li>US-ASCII: fits in 7 bits or you can't say it</li>
<li>ISO-8859-1 (a.k.a. Latin-1): Characters for most Western European languages in 8 bits</li>
<li>Windows-1252: Similar to and often confused with ISO-8859-1</li>
<li>UTF-8: Superset of ASCII using upper bits to indicate multi-byte characters</li>
</ul>

<p>As far as I'm concerned, there's no reason to use anything except UTF-8 except for compatibility.  ISO-8859-1 (usually actually Windows-1252) seems to be pretty common, though.</p>

<p>Now let's complicate matters...</p>

<hr />

<p class="signquot">HTML Text
<br /><br/>(i.e. the stuff between &gt; and &lt;)</p>

<p>I'm not going to go into HTML structural markup - only about pieces of HTML that represent actual text.  i.e. the pieces of the document between the tags.</p>

<p>Parsing text from HTML is one step more complex than reading plain text because not only do you have to translate bytes to characters, but you also have to interpret escape sequences.  Since angle brackets and ampersands have special meaning, they <em>must</em> be escaped in HTML text, either as entities or numeric references.  But it's perfectly valid to escape any character, even if it has no special meaning.</p>

<hr />

<table class="signquot chartable">
<tr><th>Entity</th><th>Numeric</th><th>Text</th></tr>
<tr><td>&amp;amp;</td><td>&amp;#38;</td><td>&amp;</td></tr>
<tr><td>&amp;lt;</td><td>&amp;#60;</td><td>&lt;</td></tr>
<tr><td></td><td>&amp;#65;</td><td>A</td></tr>
<tr><td></td><td>&amp;#35987;</td><td>&#35987;</td></tr>
</table>

<p>Note that if you escape something <em>twice</em>, you will







<p>Now I'm going to go over an example of how <em>not</em> paying attention to encoding could get you in trouble.</p>

TODO: make a real example

<hr />
<hr />

<!--
<pre class="signquot" style="text-align:left; margin-left:auto; margin-right:auto">
$mahText = file_get_contents('mahfile.txt');
$mahHtml = htmlentities($mahText);

echo "&lt;html&gt;&lt;body>\n\n&lt;p&gt;The file says:&lt;/p&gt;\n\n";
echo "&lt;pre&gt;$mahHtml&lt;/pre&gt;\n\n&lt;/body&gt;&lt;/html&gt;"
</pre>

<p>At first glance this code looks fine.  Thing is, htmlentities encodes certain characters to HTML entities, but we're passing it a PHP string, which is actually just a bunch of bytes with no information about how characters are encoded.  So it has to decode the characters internally, and we didn't tell it what character encoding to use.  It defaults to ISO-8859-1.  So if your mahfile.txt was UTF-8 encoded and full of chinese characters, your HTML output would be full of little boxes and </p>

<!--The method by which code points are translated to and from sequences of bits or bytes called a "character encoding"</p>-->

<hr />


<p>Here's examples of different kinds of strings:</p>

<ul class="signquot" style="text-align:left">
<li>ASCII: fits in 7 bits or you can't say it</li>
<li>Multibyte: reserve several bytes for each character</li>
<li>JSON String: <code>"cat = \u8C93"</code></li>
<li>X/HTML-entity-encoded: <code>cat = &amp;#35987;</code></li>
<li>UTF-8: Superset of ASCII using upper bits to indicate multi-byte characters</li>
</ul>

<!--
<p>I thought of adding URL-encoding to the list, but decided it wasn't much of a character encoding because URL escape sequences are used to encode bytes, which in turn need to be interpreted either as ASCII or UTF-8.</p>
-->

<p>Any one of these methods may be used to encode a string of characters.  And as long as you know how your string is encoded, you can get it back out by decoding using the same method.</p>

<hr />

<p>You can even encode things multiple times so long as you are sure to decode using the same methods in reverse order.</p>

<p style="color:red">TODO: This sucks.
This talk is really about reversible transformations more than character encodings,
especially since you get into X/HTML entities, which aren't really 'character encodings' at all.
Reword/rewrite to reflect this.</p>

<div class="signquot" style="text-align:left">
xmlencode(&#35987;) = &amp;#35987;<br />
xmlencode(xmlencode(&#35987;)) = &amp;#35987;<br />
jsonencode(&#35987;) = "\u8C93"<br />
jsonencode(xmlencode(&#35987;)) = "&amp;#35987;"<br />
xmlencode(jsonencode(&#35987;)) = "\u8C93"
</div>

<p>And you don't have to be the one doing the decoding, either.  If you tell a web browser that you are sending it an HTML document, then send it xmlencode(&#35987;), it will show up on the users screen as &#35987;, because the web browser is doing the decoding.</p>

<hr />

<p class="signquot">&#35987;</p>

</p>On the other hand, if you xmlencode it twice, then the web browser will show something this:</p>

<hr />

<p class="signquot">&amp;#35987;</p>

<p>Which might be usful if you're writing an article about character encodings.</p>

<hr />

<p>But otherwise you don't even need to X/HTML-entity-encode this particular character, as it has no special meaning to X/HTML.  But in this case you and the browser do need to agree on a byte-character encoding.  The easiest way to do this is to send out a header declaring the content type to be:</p>

<p class="signquot">text/html; charset=utf-8</p>

<p>and then making sure that all the strings you are outputting really are UTF-8.</p>

<p>This indicates that the stream of bytes the browser recieves should be transformed to a sequence of characters using UTF-8, and then that sequence of characters should be parsed as HTML.</p>

<p>That there are 2 levels of encodings here (one from bytes to characters, and another from characters to formatting+characters) is probably what gets people confused, especially since you can choose whether to encode non-ASCII characters at the HTML-level or not.</p>

<p>(Question to audience) Any questions now?</p>

<p>Now, if for some reason you can't specify the charset header (say, because the website is already written to output using a different charset), then you should X/HTML-entity-encode any non-ASCII characters.  This is actually the route we've taken to work with text on Schweser.  Anything that's not ASCII text we encode using HTML entities, but that means we need to keep track of what those fields are and be sure to treat them as being HTML-entity-encoded.  Otherwise the users will see a bunch of ampersands in their text.</p>

<hr />

<h3>PHP functions</h3>

<p>As far as I can tell, neither of the 2 built-in PHP functions, htmlentities or htmlspecialchars, will entity-encode all non-ASCII characters.  This means that if you are using them to encode data to be sent to a browser, non-ASCII byte characters will slip right past, and you are relying on the character set/encoding named in the header matching that of the string you're outputting.  If we could entity-encode <em>all</em> non-ASCII characters, then the resulting HTML will be pure ASCII, and since that is a subset of both ISO-8859-1 and UTF-8 (probably the 2 character encodings most likely to be default), we can stop worrying about backing character encodings, as long as we can rely on the client properly handling X/HTML entities.</p>

<p>Therefore I have written this function...</p>

</body>
</html>
