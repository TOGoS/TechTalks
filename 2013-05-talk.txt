# Be Precise and Don't Repeat Yourself: How to Talk to Computers

I argue that:

By writing programs in terms of what to do rather than how to do them,
your programs will be have fewer bugs, easier to maintain, probably mor
efficient, and if not more efficient, easier to optimize so that they are.

## Quick example

Server code for a simple web site that says "Hello, <name>" when you go to
/hello, "Goodbye, <name>" for any other URL.

    class SomethingController {
      var $request;
      var $response;
      var $whatToSay = "Goodbye";
      var $name = '';
      
      function initHello() {
        $this->whatToSay = "Hello";
      }
      
      function handleRequest() {
        $this->name = $this->request->getParameterValue('name');
        if( $this->request->pathInfo == '/hello' ) {
          $this->initHello();
        }
        $this->response->print($this->whatToSay . ', ' . $this->name);
      }
    }

Problems:
- Not obvious how to provide alternate response codes
- To understand what the code is doing, need to make assumptions
  about how it's called and track side-effects in your head
  - e.g. what request and response are
  - at what point in the code are the various instance variables
    set to the value you want
- Controller object holds state for a single request/response, so
  cannot be re-used (that it won't be requires another assumption
  about the environment)
- Chunks of code could be left out and the program would still be
  syntactically correct but wrong.

Better solution:

    class SomethingRequestHandler {
      function handleRequest( Request $request ) {
        return new Response( 200,
          ($request->pathInfo == '/hello' ? "Hello" : "Goodbye") . ', ' .
          $request->getParameterValue('name') );
      }
    }

This is a more direct mapping of our requirements to code, so it's more
understandable.  It's also better code for other reasons.
- Since the controller is stateless and the $request, there's no room for
  the handleRequest method to be called incorrectly.
- Taking advantage of simple language features (function parameters and
  return values, in this case) cuts down on boilerplate code, which
  means other programmers can read and understand the code with less
  effort.
- By defining the request handler as a function, we are more clearly
  modeling our solution.  After all, the response is _a function of_
  the request.

Even better, use a language with static typing a decent compiler:

    class SomethingRequestHandler {
      Response handleRequest( Request req ) {
        return new Response( 200,
          (req.pathInfo == "/hello" ? "Hello" : "Goodbye") + ", " +
          req.getParameterValue("name") );
      }
    }

Static typing serves as documentation for both the compiler and for
other programmers.
- It's obvious what request and response must be - no need to poke around
  in calling code or even read the documentation to understand how
  the function is used.
- It allows the compiler to catch type mismatch problems that might cause
  subtle bugs in less strict languages.
- It allows the compiler to make optimizations.

A decent compiler can point out obvious problems with your code before you
even run it.  Which means your programs are much more likely to work the
first time you run them and much less likely to have uncaught bugs.
When working on TOPS (a Java project) I did a major refactoring that would
have taken weeks and probably left subtle bugs all over if the code I
was working on had been written in a language without compile-time checks
(such as PHP).

## Git

Git is a good version control system because it explicitly models the
relationship between versions your project.

Git is a directed graph, where nodes are snapshots of your project
and edges point to parent commits.  This core model says nothing about
servers or authentication mechanisms and because of this decoupling
it a much more robust system than, say, subversion.

- You can duplicate repositories willy-nilly without
- Branches are free.  You can work on your own without
  pulling or pushing changes for a few days, and if someone else does
  work from the same start point, you've each made an anonymous branch.
  If only one person does this at a time and pushes back to the central
  repository when they're done, the history stays nice and linear.
  This nice stuff happens _automatically_ due to the data model.
- This model also allows merging to be done automatically.
  Since git explicitly tracks parent commits, it can walk the
  commit history to find a the first common ancestor commit and
  only apply changes after that point, so 

The reason Git is successful is because it separates the data model
from how the data is managed, which makes the model simpler, which
makes it easier for people to deal with and makes it easier to build
tools that interact with it (e.g. GitHub).

Separating the data model from how the data is managed is something
that our projects can benefit from, too.  And to some extent we
already do this when we start a project by designing the database
first.  Relational databases happen to be pretty good at modelling the
kind of data that our projects work with.  If your project involves
the concept of a user, a product, a shopping cart, a hospitalization
diagnosis, chances are there will be tables in the database with those
same names, and their relation to their corresponding real-world
object or abstract concept will be very obvious.

Question for the audience: Why aren't the objects in our
PHP/JavaScript code as obvious and easily understandable as our
database schemas?

I think they can be if you write your program in such a way that your
code maps directly to your ideas.  In my experience sticking to
immutable data structures and modelling functions as functions helps a
lot.  But that's for a different talk.  So is character encodings.

## SchemaSchema

SchemaSchema is a language for declaring your data model and a Java
library that interprets it.  Here's an example from First30:

    resource class 'provider type' : scope @ constant {
        provider type code : string : key(primary)
        name : string
        is community resource type : boolean
    }
    
    resource class 'provider' : scope @ org-tree {
        ID : entity ID : key(primary)
        defining organization ID : entity ID
        provider type code : string
        name : string : nullable
        name prefix : string : nullable
        first name : string : nullable
        last name : string : nullable
        name suffix : string : nullable
        description : string
        e-mail address : string : nullable
        phone number : string : nullable
        website URL : string : nullable
        address : postal address : nullable
    }

You may ask: Why not just write your CREATE TABLE scripts in SQL and
call that your data model?

SchemaSchema allows you to define common data types and
use them over and over.  If the definitions change (e.g. a user ID
used to be represented as a 32-bit integer but now it needs to be 64
bits) you can simply change the definition and re-generate your table
creation SQL.  If you need to upgrade your database, you can use
SchemaSchema to find all columns of type 'user ID' and 

SchemaSchemas can also declare things about your schema that aren't
limited to how it's represented in the database.  E.g. you can
indicate how certain values should be encoded in JSON or PHP.  In
First30 we have various scopes, and the SchemaSchema document
indicates the scope for each table, allowing us to auto-generate data
used by the permission checking functions.

It also serves as documentation that's more easily readable than your
table creation SQL.

TODO: say more stuff
