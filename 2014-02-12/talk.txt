I had run out of things to do for First30 and decided it was time to
learn Haskell because I'd heard nice things about it.  Pitt said I
should make a talk about it.

I haven't yet written any useful programs in Haskell so I can't give
an informed opinion about its strengths or weaknesses for large
projects, so instead I'll just give an overview of the language and
talk about how it differs from imperative languages that most of us
are used to.

To get started, here's Hello, world in Haskell:

  main :: IO ()
  main = putStrLn "Hello, world!"

Unless you've programmed in Haskell or a Haskell-like language before,
this is probably Greek to you.

In order to explain what's going on here I need to explain that
Haskell is a purely functional language, which means that functions
are not allowed to have side-effects.  Which may lead you to ask
"How can your program print 'Hello, world!' if no side-effects are allowed?".
The answer is that while ~functions~ may not have side-effects, Haskell
has a notion of 'actions', separate from functions, which /do/ have side-effects.

The type for 'action' is spelled 'IO <return value type>', where "()"
is used to indicate no result, hence, in our example, 'main' being of
type 'IO ()'.  Main is an action that has side effects but doesn't
return anything.  We're defining main as the result of calling
putStrLn with a single argument, the literal string "Hello, world!",
putStrLn being a function that doesn't actually output anything on its
own, but that returns an action that, when run, will output "Hello,
world!"

So to summarize...

  -- Main's type is 'action that returns nothing'
  main :: IO ()
  
  -- Main is the result of calling (putStrLn "Hello, world!")
  main = putStrLn "Hello, world!"

Next I will talk about some of Haskell's operators that make Haskell
programs appear incomprehensible until you know what they mean.

  >>

Is used to combine actions.  It means 'action on the left, followed by action on the right'.
If we wanted our 'main' action to do more than one thing, we could use this:

  main =
    putStrLn "I shall write this line, and then another!" >>
    putStrLn "This is the second line."

Relatedly,

  >>=

Is used to combine an action with a function that takes the action's
result and returns another action.  We would use this if we wanted to
take some input and then act on it:

  main = getLine >>= putStrLn

Indicates that main is an action that reads a line from standard input
and passes the result of getLine (which happens to be a string) to
putStrLn, and then run the action that putStrLn returns.  i.e.
main will read a line and then spit it back at you.

Haskell provides another way to write action chains, 'do' blocks:

  main = do
    l <- getLine
    putStrLn l

This is interpreted like:

  main =
    getLine >>=
    (\l -> putStrLn l)

Where (\l -> ...) defines an anonymous function that takes 'l' and passes it to putStrLn.
Some people say the 'do' notation is harmful because it obscures this, and
at this point feel like I agree with that sentiment.

  $

The dollar operator applies a function.
Since this has lower precedence than a space,
people sometimes like to use this to cut down on parentheses.
Example:

  some function call (another function call)

Can be rewritten as:

  some function call $ another function call

Note that in Haskell, all functions are automatically curried.

  foo bar baz

Has the exact same meaning as

  (((foo) bar) baz)

